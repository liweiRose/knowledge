<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Network | Summary of front-end knowledge system</title>
    <meta name="description" content="Knowledge summary">
    
    
    <link rel="preload" href="/knowledge/assets/css/0.styles.ee382328.css" as="style"><link rel="preload" href="/knowledge/assets/js/app.c7c9f3cb.js" as="script"><link rel="preload" href="/knowledge/assets/js/2.d289c607.js" as="script"><link rel="preload" href="/knowledge/assets/js/35.574acac1.js" as="script"><link rel="prefetch" href="/knowledge/assets/js/10.0b36faa9.js"><link rel="prefetch" href="/knowledge/assets/js/11.2259b3cd.js"><link rel="prefetch" href="/knowledge/assets/js/12.f205341e.js"><link rel="prefetch" href="/knowledge/assets/js/13.f94e3938.js"><link rel="prefetch" href="/knowledge/assets/js/14.85ef3d7c.js"><link rel="prefetch" href="/knowledge/assets/js/15.59e21c6f.js"><link rel="prefetch" href="/knowledge/assets/js/16.7da8ddbd.js"><link rel="prefetch" href="/knowledge/assets/js/17.426c6433.js"><link rel="prefetch" href="/knowledge/assets/js/18.8e929af7.js"><link rel="prefetch" href="/knowledge/assets/js/19.7ff67bd8.js"><link rel="prefetch" href="/knowledge/assets/js/20.fef1ac69.js"><link rel="prefetch" href="/knowledge/assets/js/21.5d79ad14.js"><link rel="prefetch" href="/knowledge/assets/js/22.163fe03c.js"><link rel="prefetch" href="/knowledge/assets/js/23.b8dd4df8.js"><link rel="prefetch" href="/knowledge/assets/js/24.778c4a31.js"><link rel="prefetch" href="/knowledge/assets/js/25.f073823c.js"><link rel="prefetch" href="/knowledge/assets/js/26.11dfbeac.js"><link rel="prefetch" href="/knowledge/assets/js/27.849b779c.js"><link rel="prefetch" href="/knowledge/assets/js/28.e5a7709a.js"><link rel="prefetch" href="/knowledge/assets/js/29.034e998d.js"><link rel="prefetch" href="/knowledge/assets/js/3.5ecd6063.js"><link rel="prefetch" href="/knowledge/assets/js/30.ab808b97.js"><link rel="prefetch" href="/knowledge/assets/js/31.cc8fb9ee.js"><link rel="prefetch" href="/knowledge/assets/js/32.8e8a589a.js"><link rel="prefetch" href="/knowledge/assets/js/33.b05e31dd.js"><link rel="prefetch" href="/knowledge/assets/js/34.140fb0e6.js"><link rel="prefetch" href="/knowledge/assets/js/36.6b9ecf53.js"><link rel="prefetch" href="/knowledge/assets/js/37.d83a79ef.js"><link rel="prefetch" href="/knowledge/assets/js/38.8c46eea8.js"><link rel="prefetch" href="/knowledge/assets/js/39.90c4d929.js"><link rel="prefetch" href="/knowledge/assets/js/4.3ff2fe10.js"><link rel="prefetch" href="/knowledge/assets/js/40.bb9b504d.js"><link rel="prefetch" href="/knowledge/assets/js/41.28ba6c64.js"><link rel="prefetch" href="/knowledge/assets/js/42.e05422fe.js"><link rel="prefetch" href="/knowledge/assets/js/43.84bcb027.js"><link rel="prefetch" href="/knowledge/assets/js/44.81af2084.js"><link rel="prefetch" href="/knowledge/assets/js/45.7632bb53.js"><link rel="prefetch" href="/knowledge/assets/js/46.c74f5065.js"><link rel="prefetch" href="/knowledge/assets/js/47.3c71dc4f.js"><link rel="prefetch" href="/knowledge/assets/js/48.aedb7972.js"><link rel="prefetch" href="/knowledge/assets/js/49.ac698661.js"><link rel="prefetch" href="/knowledge/assets/js/5.da6fa144.js"><link rel="prefetch" href="/knowledge/assets/js/50.3741ddd9.js"><link rel="prefetch" href="/knowledge/assets/js/51.9dde8b60.js"><link rel="prefetch" href="/knowledge/assets/js/52.36c4d531.js"><link rel="prefetch" href="/knowledge/assets/js/53.421f800e.js"><link rel="prefetch" href="/knowledge/assets/js/54.393bde0d.js"><link rel="prefetch" href="/knowledge/assets/js/55.2153d654.js"><link rel="prefetch" href="/knowledge/assets/js/56.0e02b55d.js"><link rel="prefetch" href="/knowledge/assets/js/57.e0358f2e.js"><link rel="prefetch" href="/knowledge/assets/js/58.1050faaa.js"><link rel="prefetch" href="/knowledge/assets/js/59.009446f1.js"><link rel="prefetch" href="/knowledge/assets/js/6.8831997f.js"><link rel="prefetch" href="/knowledge/assets/js/60.0691b8f7.js"><link rel="prefetch" href="/knowledge/assets/js/61.497e26a6.js"><link rel="prefetch" href="/knowledge/assets/js/62.7ea885de.js"><link rel="prefetch" href="/knowledge/assets/js/63.80176431.js"><link rel="prefetch" href="/knowledge/assets/js/64.24560797.js"><link rel="prefetch" href="/knowledge/assets/js/65.1d31560a.js"><link rel="prefetch" href="/knowledge/assets/js/66.36e591f4.js"><link rel="prefetch" href="/knowledge/assets/js/67.3dbf9497.js"><link rel="prefetch" href="/knowledge/assets/js/68.19535fe2.js"><link rel="prefetch" href="/knowledge/assets/js/69.a4ece792.js"><link rel="prefetch" href="/knowledge/assets/js/7.061bea16.js"><link rel="prefetch" href="/knowledge/assets/js/70.bd6bff90.js"><link rel="prefetch" href="/knowledge/assets/js/71.d39accd7.js"><link rel="prefetch" href="/knowledge/assets/js/72.905b06e0.js"><link rel="prefetch" href="/knowledge/assets/js/73.ecc2a10b.js"><link rel="prefetch" href="/knowledge/assets/js/74.b3f40af3.js"><link rel="prefetch" href="/knowledge/assets/js/75.583fcf8a.js"><link rel="prefetch" href="/knowledge/assets/js/76.bdf6299f.js"><link rel="prefetch" href="/knowledge/assets/js/77.6a278b38.js"><link rel="prefetch" href="/knowledge/assets/js/78.a6442553.js"><link rel="prefetch" href="/knowledge/assets/js/79.31f9d565.js"><link rel="prefetch" href="/knowledge/assets/js/8.efb283ac.js"><link rel="prefetch" href="/knowledge/assets/js/80.cfa2fcbf.js"><link rel="prefetch" href="/knowledge/assets/js/81.e6799d45.js"><link rel="prefetch" href="/knowledge/assets/js/82.08ef4247.js"><link rel="prefetch" href="/knowledge/assets/js/83.d3b24c85.js"><link rel="prefetch" href="/knowledge/assets/js/84.eddd85b3.js"><link rel="prefetch" href="/knowledge/assets/js/85.61c27332.js"><link rel="prefetch" href="/knowledge/assets/js/9.5321aaf5.js">
    <link rel="stylesheet" href="/knowledge/assets/css/0.styles.ee382328.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/knowledge/" class="home-link router-link-active"><!----> <span class="site-name">Summary of front-end knowledge system</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://github.com/liweirose" target="_blank" rel="noopener noreferrer" class="nav-link external">
  更多
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <a href="https://github.com/liweirose/knowledge" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://github.com/liweirose" target="_blank" rel="noopener noreferrer" class="nav-link external">
  更多
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <a href="https://github.com/liweirose/knowledge" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Browser</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>HTML</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>CSS</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JavaScript</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JavaScript ES6</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JS Utils</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Interview</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/knowledge/app/Interview/Interview-html.html" class="sidebar-link">HTML</a></li><li><a href="/knowledge/app/Interview/Interview-css.html" class="sidebar-link">CSS</a></li><li><a href="/knowledge/app/Interview/Interview-javascript.html" class="sidebar-link">JavaScript</a></li><li><a href="/knowledge/app/Interview/Interview-network.html" class="active sidebar-link">Network</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/knowledge/app/Interview/interview-browser.html" class="sidebar-link">Browser</a></li><li><a href="/knowledge/app/Interview/interview-framework.html" class="sidebar-link">Framework</a></li><li><a href="/knowledge/app/Interview/Interview-algorithm.html" class="sidebar-link">算法 相关</a></li><li><a href="/knowledge/app/Interview/Interview-data-structure.html" class="sidebar-link">数据结构</a></li><li><a href="/knowledge/app/Interview/interview-summary.html" class="sidebar-link">面试总结</a></li><li><a href="/knowledge/app/Interview/interview-performance.html" class="sidebar-link">性能优化</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Engineering</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Engineering Practice</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Underscore SourceCode Parsing</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Lodash SourceCode Parsing</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Plan List</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="network"><a href="#network" class="header-anchor">#</a> Network</h1> <h3 id="tcp-三次握手-四次挥手"><a href="#tcp-三次握手-四次挥手" class="header-anchor">#</a> TCP 三次握手 四次挥手</h3> <p>建立和断开连接的一种策略</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">1.</span> 连接

  ① 发送端 发送 一个带<span class="token constant">SYN</span>标志的数据包 给接收端

  ② 接收端收到后，回传 一个带有<span class="token constant">SYN</span><span class="token operator">/</span><span class="token constant">ACK</span>标志的数据包 确认收到了信息

  ③ 发送端再回传 一个带<span class="token constant">ACK</span>标志的数据包 代表“握手”结束

 tips<span class="token punctuation">:</span> 若在握手过程中某个阶段莫名中断，<span class="token constant">TCP</span>协议会再次以相同的顺序发送相同的数据包
<span class="token number">2.</span> 断开 <span class="token constant">TCP</span> 连接

  ① 主动关闭方 发送一个 <span class="token constant">FIN</span> <span class="token punctuation">(</span>告知对方我已经不再发送数据了<span class="token punctuation">)</span>

  ② 被动关闭方 收到<span class="token constant">FIN</span>包后，发送一个<span class="token constant">ACK</span>给对方，确认序号为收到序号<span class="token operator">+</span><span class="token number">1</span>

  ③ 被动关闭方 再发送一个<span class="token constant">FIN</span> （ 告诉主动关闭方，我的数据也发送完了，不会再给你发数据了 ）

  ④ 主动关闭方 收到<span class="token constant">FIN</span>后，发送一个<span class="token constant">ACK</span>给被动关闭方，确认序号为收到序号<span class="token operator">+</span><span class="token number">1</span>

</code></pre></div><h3 id="tcp-和-udp-的区别"><a href="#tcp-和-udp-的区别" class="header-anchor">#</a> TCP 和 UDP 的区别</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">1.</span> <span class="token constant">TCP</span>（Transmission Control Protocol，传输控制协议）

  <span class="token operator">-</span> <span class="token constant">TCP</span> 是基于连接的协议，在正式收发数据前，必须和对方建立可靠的连接。
  <span class="token operator">-</span> 一个 <span class="token constant">TCP</span> 连接必须要经过三次“对话”才能建立起来。

<span class="token number">2.</span> <span class="token constant">UDP</span>（User Data Protocol，用户数据报协议）

  <span class="token operator">-</span> <span class="token constant">UDP</span> 是与 <span class="token constant">TCP</span> 相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去。

  <span class="token operator">-</span> <span class="token constant">UDP</span> 适用于一次只传送少量数据、对可靠性要求不高的应用环境。
</code></pre></div><h3 id="常见-web-安全"><a href="#常见-web-安全" class="header-anchor">#</a> 常见 web 安全</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">1.</span> <span class="token function">Xss</span><span class="token punctuation">(</span>cross<span class="token operator">-</span>site scripting<span class="token punctuation">)</span>攻击

<span class="token operator">-</span> 指的是攻击者往 Web 页面里插入恶意 html 标签或者 javascript 代码

<span class="token operator">-</span> 如：攻击者在论坛中加一个恶意表单

  <span class="token operator">-</span> 如果网站不需要再浏览器端对 cookie 进行操作，可以在 Set<span class="token operator">-</span>Cookie 末尾加上 HttpOnly 
    来防止 javascript 代码直接获取 cookie
  <span class="token operator">-</span> 尽量采用 <span class="token constant">POST</span> 而非 <span class="token constant">GET</span> 提交表单

<span class="token number">2.</span> <span class="token constant">CSRF</span> 攻击

<span class="token operator">-</span> <span class="token constant">CSRF</span> 是代替用户完成指定的动作

<span class="token operator">-</span> 完成一次 <span class="token constant">CSRF</span> 攻击，受害者必须依次完成两个步骤：

  <span class="token operator">-</span> 登录受信任网站 <span class="token constant">A</span>，并在本地生成 Cookie
  <span class="token operator">-</span> 在不登出 <span class="token constant">A</span> 的情况下，访问危险网站 <span class="token constant">B</span>

<span class="token operator">-</span> 在客户端页面增加伪随机数以防御
</code></pre></div><h3 id="http-和-https"><a href="#http-和-https" class="header-anchor">#</a> HTTP 和 HTTPS</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">1.</span> <span class="token constant">HTTP</span>

<span class="token operator">-</span> <span class="token constant">HTTP</span> 协议通常承载于 <span class="token constant">TCP</span> 协议之上
<span class="token operator">-</span> 默认 <span class="token constant">HTTP</span> 的端口号为 <span class="token number">80</span>

<span class="token number">2.</span> <span class="token constant">HTTPS</span>

<span class="token operator">-</span> 在 <span class="token constant">HTTP</span> 和 <span class="token constant">TCP</span> 之间添加一个安全协议层（<span class="token constant">SSL</span> 或 <span class="token constant">TSL</span>）

<span class="token operator">-</span> <span class="token constant">HTTPS</span> 的端口号为 <span class="token number">443</span>

<span class="token operator">-</span> 安全性强

  <span class="token operator">-</span> 因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，所以 <span class="token constant">HTTP</span> 存在安全性问题

  <span class="token operator">-</span> 使用 <span class="token constant">HTTPS</span>，密钥在你和终点站才有。

  <span class="token operator">-</span> 利用 ssl<span class="token operator">/</span>tls <span class="token function">协议传输</span> <span class="token punctuation">(</span>它包含证书，卸载，流量转发，负载均衡，页面适配，浏览器适配，refer 传递等<span class="token punctuation">)</span>

  <span class="token operator">-</span> 从而保障了传输过程的安全性。

<span class="token number">3.</span> Http <span class="token number">2.0</span>

<span class="token operator">-</span> <span class="token constant">HTTP</span><span class="token operator">/</span><span class="token number">2</span>  引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前就主动地将数据
          发送到客户端缓存中，从而提高性能。

<span class="token operator">-</span> <span class="token constant">HTTP</span><span class="token operator">/</span><span class="token number">2</span>  提供更多的加密支持。

<span class="token operator">-</span> <span class="token constant">HTTP</span><span class="token operator">/</span><span class="token number">2</span>  使用多路技术，允许多个消息在一个连接上同时交差。

<span class="token operator">-</span> <span class="token constant">HTTP</span><span class="token operator">/</span><span class="token number">2</span>  增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的 header 
          都只会占用很小比例的带宽。
</code></pre></div><h3 id="cookie-和-session"><a href="#cookie-和-session" class="header-anchor">#</a> Cookie 和 session</h3> <ul><li><p>Cookie 是一种存储机制，提供持久保存客户端数据的能力</p></li> <li><p>session 对象存储在 Cookie 中， 保存一些常用的信息，如：access_token/user_info</p></li> <li><p>cookie 数据存放在客户的浏览器上，session 数据放在服务器上</p></li> <li><p>每个特定的域名下最多生成 20 个 Cookie</p></li> <li><p>Cookie 的最大约为 4096 字节，为了兼容性，一般不能超过 4095 字节</p></li> <li><p>每次请求一个新的页面 Cookie 都会被发送过去</p></li></ul> <h4 id="应用"><a href="#应用" class="header-anchor">#</a> 应用</h4> <p>由于 http 无状态，所以需要存在一种机制去标识状态</p> <div class="language- extra-class"><pre class="language-text"><code>- 基于 Cookie 的身份验证 &amp; 验证流程

  - 因为 cookie 验证有状态 所以会话信息(session) 同时保存在客户端(cookie) 和 服务端(sql)

  - cookie 绑定单域 a.com 生成的不能再 b.com 中用

  - 流程:
    - 用户登录获取凭证
    - 服务器验证凭证正确与否
    - 若验证通过创建会话（set-cookie）(服务端存一份，浏览器端直接写入到 cookie，根据是否设置 http-only 决定浏览器端是否可操作 cookie，获取 session 拿到凭证信息)
    - 后续请求均走上述验证流程
    - 若 用户登出 则服务端与浏览器端同时清除 session

- 基于 Token 的身份验证 &amp; 验证流程

  - 基于 JWT（JSON Web Tokens）生成 token
  - 服务端不需要记录 token
  - 多站点使用
  - 支持 ios/Android
  - 性能较好

  - 流程：
    - 用户登录获取凭证
    - 服务器验证凭证，成功则返回一个已经签名后的 token
    - 客服端存储 token
    - 客服端请求，头里带上 token
    - 服务端校验 token 合法性, 是否过期等
    - 用户登出 客户端销毁 token
</code></pre></div><h3 id="sessionstorage-和-localstorage"><a href="#sessionstorage-和-localstorage" class="header-anchor">#</a> sessionStorage 和 localStorage</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">1.</span> sessionStorage

sessionStorage 用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且
当会话结束后数据也随之销毁。因此 sessionStorage 不是一种持久化的本地存储，仅仅是会话级别的存储。

<span class="token number">2.</span> localStorage

localStorage 用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。
</code></pre></div><h3 id="一个页面从输入-url-到页面加载显示完成，这个过程中都发生了什么？"><a href="#一个页面从输入-url-到页面加载显示完成，这个过程中都发生了什么？" class="header-anchor">#</a> 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？</h3> <ul><li><p>（1) 当发送一个 URL 请求时，不管这个 URL 是 Web 页面的 URL 还是 Web 页面上每个资源的 URL，浏览器都会开启一个线程来处理这个请求，同时在远程 DNS 服务器上启动一个  DNS 查询。这能使浏览器获得请求对应的 IP 地址。</p></li> <li><p>（2)浏览器与远程<code>Web</code>服务器通过<code>TCP</code>三次握手协商来建立一个<code>TCP/IP</code>连接。该握手包括一个同步报文，一个同步-应答报文和一个应答报文， 这三个报文在 浏览器和服务器之间传递。该握手首先由客户端尝试建立起通信，而后服务器应答并接受客户端的请求，最后由客户端发出该请求已经被接受的报文。</p></li> <li><p>（3)一旦<code>TCP/IP</code>连接建立，浏览器会通过该连接向远程服务器发送<code>HTTP</code>的<code>GET</code>请求。远程服务器找到资源并使用 HTTP 响应返回该资源，值为 200 的 HTTP 响应状态表示一个正确的响应。</p></li> <li><p>（4)此时，<code>Web</code>服务器提供资源服务，客户端开始下载资源。</p></li> <li><p>（5)前端层面，浏览器会解析<code>HTML</code>生成<code>DOM Tree</code>，其次会根据 CSS 生成 CSS Rule Tree，而<code>javascript</code>又可以根据<code>DOM API</code>操作<code>DOM</code></p></li></ul> <div class="language- extra-class"><pre class="language-text"><code>
  详细版：
  1、浏览器会开启一个线程来处理这个请求，对 URL 分析判断如果是 http 协议就按照 Web 方式来处理;
  2、调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法;
  3、通过 DNS 解析获取网址的 IP 地址，设置 UA 等信息发出第二个 GET 请求;
  4、进行 HTTP 协议会话，客户端发送报头(请求报头);
  5、进入到 web 服务器上的 Web Server，如 Apache、Tomcat、Node.JS 等服务器;
  6、进入部署好的后端应用，如 PHP、Java、JavaScript、Python 等，找到对应的请求处理;
  7、处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致则返回 304;
  8、浏览器开始下载 html 文档(响应报头，状态码 200)，同时使用缓存;
  9、文档树建立，根据标记请求所需指定 MIME 类型的文件（比如 css、js）,同时设置了 cookie;
  10、页面开始渲染 DOM，JS 根据 DOM API 操作 DOM,执行事件绑定等，页面显示完成。

  简洁版：
  浏览器根据请求的 URL 交给 DNS 域名解析，找到真实 IP，向服务器发起请求；
  服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）；
  浏览器对加载到的资源（HTML、JS、CSS 等）进行语法解析，建立相应的内部数据结构（如 HTML 的 DOM）；
  载入解析到的资源文件，渲染页面，完成。

</code></pre></div><blockquote><p>这里可扩展，这里只是简单说说</p></blockquote> <h3 id="同源策略"><a href="#同源策略" class="header-anchor">#</a> 同源策略</h3> <ul><li><p>指的是：协议，域名，端口相同，同源策略是一种安全协议</p></li> <li><p>为什么要有同源限制?</p> <ul><li>因为可以利用 Iframe 把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过 Javascript 读取到你的表单中 input 中的内容</li></ul></li></ul> <h3 id="get-和-post-的区别，何时使用-post？"><a href="#get-和-post-的区别，何时使用-post？" class="header-anchor">#</a> GET 和 POST 的区别，何时使用 POST？</h3> <ul><li><p>GET：一般用于信息获取，使用 URL 传递参数，对所发送信息的数量也有限制，一般在 2000 个字符</p></li> <li><p>POST：一般用于修改服务器上的资源，对所发送的信息没有限制。</p></li> <li><p>GET 方式需要使用 Request.QueryString 来取得变量的值，而 POST 方式通过 Request.Form 来获取变量的值，也就是说 Get 是通过地址栏来传值，而 Post 是通过提交表单来传值。</p></li> <li><p>然而，在以下情况中，请使用 POST 请求：</p> <ul><li><p>无法使用缓存文件（更新服务器上的文件或数据库）</p></li> <li><p>向服务器发送大量数据（POST 没有数据量限制）</p></li> <li><p>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</p></li></ul></li></ul> <h3 id="http-状态码"><a href="#http-状态码" class="header-anchor">#</a> HTTP 状态码</h3> <div class="language-js extra-class"><pre class="language-js"><code>
<span class="token operator">-</span> <span class="token number">100</span> Continue 继续，一般在发送 post 请求时，
      已发送了 http header 之后服务端将返回此信息，表示确认，之后发送具体参数信息

<span class="token operator">-</span> <span class="token number">200</span> <span class="token constant">OK</span> 正常返回信息

<span class="token operator">-</span> <span class="token number">201</span> Created 请求成功并且服务器创建了新的资源

<span class="token operator">-</span> <span class="token number">202</span> Accepted 服务器已接受请求，但尚未处理

<span class="token operator">-</span> <span class="token number">301</span> Moved Permanently 请求的网页已永久移动到新位置。

<span class="token operator">-</span> <span class="token number">302</span> Found 临时性重定向。

<span class="token operator">-</span> <span class="token number">303</span> See Other 临时性重定向，且总是使用 <span class="token constant">GET</span> 请求新的 <span class="token constant">URI</span>。

<span class="token operator">-</span> <span class="token number">304</span> Not Modified 自从上次请求后，请求的网页未修改过。

<span class="token operator">-</span> <span class="token number">400</span> Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。

<span class="token operator">-</span> <span class="token number">401</span> Unauthorized 请求未授权。

<span class="token operator">-</span> <span class="token number">403</span> Forbidden 禁止访问。

<span class="token operator">-</span> <span class="token number">404</span> Not Found 找不到如何与 <span class="token constant">URI</span> 相匹配的资源。

<span class="token operator">-</span> <span class="token number">500</span> Internal Server Error 最常见的服务器端错误。

<span class="token operator">-</span> <span class="token number">503</span> Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。

</code></pre></div><h3 id="网络七层模型"><a href="#网络七层模型" class="header-anchor">#</a> 网络七层模型</h3> <ul><li><p>应用层：应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS）</p></li> <li><p>传输层（TCP 和 UDP）</p></li> <li><p>网络层（IP）</p></li> <li><p>物理和数据链路层（以太网）</p></li></ul> <div class="language-js extra-class"><pre class="language-js"><code>
  物理层：通过媒介传输比特<span class="token punctuation">,</span>确定机械及电气规范（比特Bit）

  数据链路层：将比特组装成帧和点到点的传递（帧Frame）

  网络层：负责数据包从源到宿的传递和网际互连（包PackeT）

  传输层：提供端到端的可靠报文传递和错误恢复（段Segment）

  会话层：建立、管理和终止会话（会话协议数据单元<span class="token constant">SPDU</span>）

  表示层：对数据进行翻译、加密和压缩（表示协议数据单元<span class="token constant">PPDU</span>）

  应用层：允许访问<span class="token constant">OSI</span>环境的手段（应用协议数据单元<span class="token constant">APDU</span>）

</code></pre></div><h3 id="网络协议"><a href="#网络协议" class="header-anchor">#</a> 网络协议</h3> <div class="language-js extra-class"><pre class="language-js"><code>
<span class="token constant">ICMP</span> 协议： 因特网控制报文协议。它是 <span class="token constant">TCP</span><span class="token operator">/</span><span class="token constant">IP</span> 协议族的一个子协议，用于在 <span class="token constant">IP</span> 主机、路由器之间传递控制消息。

<span class="token constant">TFTP</span> 协议： 是 <span class="token constant">TCP</span><span class="token operator">/</span><span class="token constant">IP</span> 协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。

<span class="token constant">HTTP</span> 协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。

<span class="token constant">DHCP</span> 协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段。

</code></pre></div><h3 id="创建ajax过程"><a href="#创建ajax过程" class="header-anchor">#</a> 创建ajax过程</h3> <div class="language- extra-class"><pre class="language-text"><code>(1)创建XMLHttpRequest对象,也就是创建一个异步调用对象.

(2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息.

(3)设置响应HTTP请求状态变化的函数.

(4)发送HTTP请求.

(5)获取异步调用返回的数据.

(6)使用JavaScript和DOM实现局部刷新.
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> xmlHttp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    xmlHttp<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'GET'</span><span class="token punctuation">,</span><span class="token string">'demo.php'</span><span class="token punctuation">,</span><span class="token string">'true'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    xmlHttp<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    xmlHttp<span class="token punctuation">.</span><span class="token function-variable function">onreadystatechange</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>

        <span class="token keyword">if</span><span class="token punctuation">(</span>xmlHttp<span class="token punctuation">.</span>readyState <span class="token operator">===</span> <span class="token number">4</span> <span class="token operator">&amp;</span> xmlHttp<span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">{</span>

        <span class="token punctuation">}</span>

    <span class="token punctuation">}</span>
</code></pre></div><h3 id="谈谈性能优化问题"><a href="#谈谈性能优化问题" class="header-anchor">#</a> 谈谈性能优化问题</h3> <p>代码层面：避免使用css表达式，避免使用高级选择器，通配选择器。</p> <p>缓存利用：缓存Ajax，使用CDN，使用外部js和css文件以便缓存，添加Expires头，服务端配置Etag，减少DNS查找等</p> <p>请求数量：合并样式和脚本，使用css图片精灵，初始首屏之外的图片资源按需加载，静态资源延迟加载。</p> <p>请求带宽：压缩文件，开启GZIP，</p> <p>代码优化:</p> <ul><li>用<code>hash-table</code>来优化查找</li> <li>少用全局变量</li> <li>用<code>innerHTML</code>代替<code>DOM</code>操作，减少<code>DOM</code>操作次数，优化<code>javascript</code>性能</li> <li>用<code>setTimeout</code>来避免页面失去响应</li> <li>缓存DOM节点查找的结果</li> <li>避免使用CSS Expression</li> <li>避免全局查询</li> <li>避免使用with(with会创建自己的作用域，会增加作用域链长度)</li> <li>多个变量声明合并</li> <li>避免图片和iFrame等的空Src。空Src会重新加载当前页面，影响速度和效率</li> <li>尽量避免写在HTML标签中写Style属性</li></ul> <h3 id="渲染优化"><a href="#渲染优化" class="header-anchor">#</a> 渲染优化</h3> <div class="language-js extra-class"><pre class="language-js"><code>    <span class="token number">1.</span>禁止使用iframe（阻塞父文档onload事件）；
        <span class="token operator">*</span>iframe会阻塞主页面的Onload事件；
        <span class="token operator">*</span>搜索引擎的检索程序无法解读这种页面，不利于<span class="token constant">SEO</span><span class="token punctuation">;</span>
        <span class="token operator">*</span>iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。

        使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript
        动态给iframe添加src属性值，这样可以绕开以上两个问题。

    <span class="token number">2.</span>禁止使用gif图片实现loading效果（降低<span class="token constant">CPU</span>消耗，提升渲染性能）；
    <span class="token number">3</span>、使用<span class="token constant">CSS3</span>代码代替<span class="token constant">JS</span>动画（尽可能避免重绘重排以及回流）；
    <span class="token number">4</span>、对于一些小图标，可以使用base64位编码，以减少网络请求。但不建议大图使用，比较耗费<span class="token constant">CPU</span>；
            小图标优势在于：
                <span class="token number">1.</span>减少<span class="token constant">HTTP</span>请求；
                <span class="token number">2.</span>避免文件跨域；
                <span class="token number">3.</span>修改及时生效；

    <span class="token number">5</span>、页面头部的<span class="token operator">&lt;</span>style<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>style<span class="token operator">&gt;</span> 会阻塞页面；（因为 Renderer进程中 <span class="token constant">JS</span>线程和渲染线程是互斥的）；
    <span class="token number">6</span>、页面头部<span class="token operator">&lt;</span>script<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span> 会阻塞页面；（因为 Renderer进程中 <span class="token constant">JS</span>线程和渲染线程是互斥的）；
    <span class="token number">7</span>、页面中空的 href 和 src <span class="token function">会阻塞页面其他资源的加载</span> <span class="token punctuation">(</span>阻塞下载进程<span class="token punctuation">)</span>；
    
    <span class="token number">8</span>、网页Gzip，<span class="token constant">CDN</span>托管，data缓存 ，图片服务器；
    <span class="token number">9</span>、前端模板 <span class="token constant">JS</span><span class="token operator">+</span>数据，减少由于<span class="token constant">HTML</span>标签导致的带宽浪费，前端用变量保存<span class="token constant">AJAX</span>请求结果，每次操作本地变量，不用请求，减少请求次数
    <span class="token number">10</span>、用innerHTML代替<span class="token constant">DOM</span>操作，减少<span class="token constant">DOM</span>操作次数，优化javascript性能。
    <span class="token number">11</span>、当需要设置的样式很多时设置className而不是直接操作style。
    <span class="token number">12</span>、少用全局变量、缓存<span class="token constant">DOM</span>节点查找的结果。减少<span class="token constant">IO</span>读取操作。
    <span class="token number">13</span>、避免使用<span class="token constant">CSS</span> Expression（css表达式<span class="token punctuation">)</span>又称Dynamic <span class="token function">properties</span><span class="token punctuation">(</span>动态属性<span class="token punctuation">)</span>。
    <span class="token number">14</span>、图片预加载，将样式表放在顶部，将脚本放在底部  加上时间戳。

    <span class="token number">15</span>、 避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div<span class="token operator">+</span>css布局慢。
        对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘<span class="token constant">IO</span>。
            向前端优化指的是，在不影响功能和体验的情况下，能在浏览器执行的不要在服务端执行，
            能在缓存服务器上直接返回的不要到应用服务器，程序能直接取得的结果不要到外部取得，
            本机内能取得的数据不要到远程取，内存能取到的不要到磁盘取，缓存中有的不要去数据库查询。
            减少数据库操作指减少更新次数、缓存结果减少查询次数、将数据库执行的操作尽可能的让你的程序完成（例如join查询），
            减少磁盘<span class="token constant">IO</span>指尽量不使用文件系统作为缓存、减少读写文件次数等。程序优化永远要优化慢的部分，换语言是无法“优化”的。
            
</code></pre></div><h3 id="什么是etag"><a href="#什么是etag" class="header-anchor">#</a> 什么是Etag</h3> <p>当发送一个服务器请求时，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断缓存文件是否过期。</p> <p>情景一：若没有过期，则不向服务器发送请求，直接使用缓存中的结果，此时我们在浏览器控制台中可以看到 <code>200 OK</code>(from cache) ，此时的情况就是完全使用缓存，浏览器和服务器没有任何交互的。</p> <p>情景二：若已过期，则向服务器发送请求，此时请求中会带上①中设置的文件修改时间，和<code>Etag</code></p> <p>然后，进行资源更新判断。服务器根据浏览器传过来的文件修改时间，判断自浏览器上一次请求之后，文件是不是没有被修改过；根据<code>Etag</code>，判断文件内容自上一次请求之后，有没有发生变化</p> <p>情形一：若两种判断的结论都是文件没有被修改过，则服务器就不给浏览器发<code>index.html</code>的内容了，直接告诉它，文件没有被修改过，你用你那边的缓存吧—— <code>304 Not Modified</code>，此时浏览器就会从本地缓存中获取<code>index.html</code>的内容。此时的情况叫协议缓存，浏览器和服务器之间有一次请求交互。</p> <p>情形二：若修改时间和文件内容判断有任意一个没有通过，则服务器会受理此次请求，之后的操作同①</p> <p>只有get请求会被缓存，post请求不会.</p> <h3 id="expires和cache-control"><a href="#expires和cache-control" class="header-anchor">#</a> Expires和Cache-Control</h3> <p><code>Expires</code>要求客户端和服务端的时钟严格同步。<code>HTTP1.1</code>引入<code>Cache-Control</code>来克服Expires头的限制。如果max-age和Expires同时出现，则max-age有更高的优先级。</p> <div class="language- extra-class"><pre class="language-text"><code>    Cache-Control: no-cache, private, max-age=0

    ETag: abcde

    Expires: Thu, 15 Apr 201420180515 20:00:00 GMT

    Pragma: private

    Last-Modified: $now // RFC1123 format
</code></pre></div><h3 id="etag应用"><a href="#etag应用" class="header-anchor">#</a> ETag应用:</h3> <p><code>Etag</code>由服务器端生成，客户端通过<code>If-Match</code>或者说<code>If-None-Match</code>这个条件判断请求来验证资源是否修改。常见的是使用<code>If-None-Match</code>。请求一个文件的流程可能如下：</p> <p>====第一次请求===</p> <div class="language- extra-class"><pre class="language-text"><code>1.客户端发起 HTTP GET 请求一个文件；

2.服务器处理请求，返回文件内容和一堆Header，当然包括Etag(例如&quot;2e681a-6-5d044840&quot;)(假设服务器支持Etag生成和已经开启了Etag).状态码200
</code></pre></div><p>====第二次请求===</p> <div class="language- extra-class"><pre class="language-text"><code>客户端发起 HTTP GET 请求一个文件，注意这个时候客户端同时发送一个If-None-Match头，这个头的内容就是第一次请求时服务器返回的Etag：2e681a-6-5d0448402.服务器判断发送过来的Etag和计算出来的Etag匹配，因此If-None-Match为False，不返回200，返回304，客户端继续使用本地缓存；流程很简单，问题是，如果服务器又设置了Cache-Control:max-age和Expires呢，怎么办
</code></pre></div><p>答案是同时使用，也就是说在完全匹配<code>If-Modified-Since</code>和<code>If-None-Match</code>即检查完修改时间和<code>Etag</code>之后，</p> <p>服务器才能返回304.(不要陷入到底使用谁的问题怪圈)</p> <p>为什么使用Etag请求头?</p> <p>Etag 主要为了解决 <code>Last-Modified</code> 无法解决的一些问题。</p> <h3 id="关于http-2-0-你知道多少"><a href="#关于http-2-0-你知道多少" class="header-anchor">#</a> 关于Http 2.0 你知道多少</h3> <p><code>HTTP/2</code>引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前就主动地将数据发送到客户端缓存中，从而提高性能。</p> <p><code>HTTP/2</code>提供更多的加密支持</p> <p><code>HTTP/2</code>使用多路技术，允许多个消息在一个连接上同时交差。</p> <p>它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的<code>header</code>都只会占用很小比例的带宽。</p> <h3 id="websocket"><a href="#websocket" class="header-anchor">#</a> WebSocket</h3> <p>由于 http 存在一个明显的弊端（消息只能有客户端推送到服务器端，而服务器端不能主动推送到客户端），导致如果服务器如果有连续的变化，这时只能使用轮询，而轮询效率过低，并不适合。于是 WebSocket 被发明出来。</p> <p>相比与 http 具有以下有点：</p> <ul><li>支持双向通信，实时性更强；</li> <li>可以发送文本，也可以二进制文件；</li> <li>协议标识符是 ws，加密后是 wss ；</li> <li>较少的控制开销。连接创建后，ws客户端、服务端进行数据交换时，协议控制的数据包头部较小。在不包含头部的情况下，服务端到客户端的包头只有2~10字节（取决于数据包长度），客- 户端到服务端的的话，需要加上额外的4字节的掩码。而HTTP协议每次通信都需要携带完整的头部；</li> <li>支持扩展。ws协议定义了扩展，用户可以扩展协议，或者实现自定义的子协议。（比如支持自定义压缩算法等）</li> <li>无跨域问题。
实现比较简单，服务端库如 socket.io、ws ，可以很好的帮助我们入门。而客户端也只需要参照 api 实现即可。</li></ul> <h3 id="浏览器缓存"><a href="#浏览器缓存" class="header-anchor">#</a> 浏览器缓存</h3> <p>浏览器缓存分为强缓存和协商缓存。当客户端请求某个资源时，获取缓存的流程如下：</p> <ul><li>先根据这个资源的一些 http header 判断它是否命中强缓存，如果命中，则直接从本地获取缓存资源，不会发请求到服务器；</li> <li>当强缓存没有命中时，客户端会发送请求到服务器，服务器通过另一些request header验证这个资源是否命中协商缓存，称为http再验证，如果命中，服务器将请求返回，但不返回资源，而是告诉客户端直接从缓存中获取，客户端收到返回后就会从缓存中获取资源；</li> <li>强缓存和协商缓存共同之处在于，如果命中缓存，服务器都不会返回资源；</li> <li>区别是，强缓存不对发送请求到服务器，但协商缓存会。</li> <li>当协商缓存也没命中时，服务器就会将资源发送回客户端。</li> <li>当 ctrl+f5 强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；</li> <li>当 f5 刷新网页时，跳过强缓存，但是会检查协商缓存；</li></ul> <h4 id="强缓存"><a href="#强缓存" class="header-anchor">#</a> 强缓存</h4> <ul><li>Expires（该字段是 http1.0 时的规范，值为一个绝对时间的 GMT 格式的时间字符串，代表缓存资源的过期时间）</li> <li>Cache-Control:max-age（该字段是 http1.1 的规范，强缓存利用其 max-age 值来判断缓存资源的最大生命周期，它的值单位为秒）</li></ul> <h4 id="协商缓存"><a href="#协商缓存" class="header-anchor">#</a> 协商缓存</h4> <ul><li>Last-Modified（值为资源最后更新时间，随服务器response返回）</li> <li>If-Modified-Since（通过比较两个时间来判断资源在两次请求期间是否有过修改，如果没有修改，则命中协商缓存）</li> <li>ETag（表示资源内容的唯一标识，随服务器response返回）</li> <li>If-None-Match（服务器通过比较请求头部的If-None-Match与当前资源的ETag是否一致来判断资源是否在两次请求之间有过修改，如果没有修改，则命中协商缓存）</li></ul> <h3 id="http-和-https-有何差异"><a href="#http-和-https-有何差异" class="header-anchor">#</a> HTTP 和 HTTPS 有何差异?</h3> <p><code>HTTP</code>相对于 <code>HTTPS</code>来说,速度较快且开销较小(没有 SSL/TSL) 对接,默认是80端口;</p> <p>HTTP容易遭受域名劫持,而HTTPS相对来说就较为安全但开销较大(数据以加密的形式传递),默认端口为443..
`
HTTP是明文跑在 TCP 上.而HTTPS跑在SSL/TLS应用层之下,TCP上的</p> <h3 id="你对-http-的状态吗了解多少"><a href="#你对-http-的状态吗了解多少" class="header-anchor">#</a> 你对 HTTP 的状态吗了解多少...</h3> <ul><li><p>1XX: 一般用来判断协议更换或者确认服务端收到请求这些</p> <ul><li>100: 服务端收到部分请求,若是没有拒绝的情况下可以继续传递后续内容</li> <li>101: 客户端请求变换协议,服务端收到确认</li></ul></li> <li><p>2xx: 请求成功,是否创建链接,请求是否接受,是否有内容这些</p> <ul><li>200: (成功)服务器已成功处理了请求。</li> <li>201: (已创建)请求成功并且服务器创建了新的资源。</li> <li>202: (已接受)服务器已接受请求，但尚未处理。</li> <li>204: (无内容)服务器成功处理了请求，但没有返回任何内容。</li></ul></li> <li><p>3XX: 一般用来判断重定向和缓存</p> <ul><li>301: 所有请求已经转移到新的 url(永久重定向),会被缓存</li> <li>302: 临时重定向,不会被缓存</li> <li>304: 本地资源暂未改动,优先使用本地的(根据If-Modified-Since or If-Match去比对服务器的资源,缓存)</li></ul></li> <li><p>4XX: 一般用来确认授权信息,请求是否出错,页面是否丢失</p> <ul><li>400: 请求出错</li> <li>401: 未授权,不能读取某些资源</li> <li>403: 阻止访问,一般也是权限问题</li> <li>404: 页面丢失,资源没找到</li> <li>408: 请求超时</li> <li>415: 媒介类型不被支持，服务器不会接受请求。</li></ul></li> <li><p>5XX: 基本都是服务端的错误</p> <ul><li>500: 服务端错误</li> <li>502: 网关错误</li> <li>504: 网关超时</li></ul></li></ul> <h3 id="从你输入一个-url-到页面渲染的大体过程"><a href="#从你输入一个-url-到页面渲染的大体过程" class="header-anchor">#</a> 从你输入一个 URL 到页面渲染的大体过程...</h3> <ul><li>IP-&gt;DNS(浏览器=&gt;系统缓存=&gt;DNS 服务器)-&gt;域名解析完成(这一步不用太多解析吧)</li> <li>TCP 协议走完-&gt;HTTP(S) 协议-&gt;缓存-&gt;(分析请求头)-&gt; 回馈报文</li> <li>请求文档下来-&gt;DOM-&gt;CSSDOM-&gt;静态资源下载-&gt;render(绘制文档)-&gt;js 解析</li> <li>用户看到页面</li></ul> <h3 id="http的几种请求方法用途"><a href="#http的几种请求方法用途" class="header-anchor">#</a> HTTP的几种请求方法用途</h3> <p>1、GET方法</p> <p>发送一个请求来取得服务器上的某一资源</p> <p>2、POST方法</p> <p>向URL指定的资源提交数据或附加新的数据</p> <p>3、PUT方法</p> <p>跟POST方法很像，也是想服务器提交数据。但是，它们之间有不同。PUT指定了资源在服务器上的位置，而POST没有</p> <p>4、HEAD方法</p> <p>只请求页面的首部</p> <p>5、DELETE方法</p> <p>删除服务器上的某资源</p> <p>6、OPTIONS方法</p> <p>它用于获取当前URL所支持的方法。如果请求成功，会有一个Allow的头包含类似“GET,POST”这样的信息</p> <p>7、TRACE方法</p> <p>TRACE方法被用于激发一个远程的，应用层的请求消息回路</p> <p>8、CONNECT方法</p> <p>把请求连接转换到透明的TCP/IP通道</p> <h3 id="_301和302-http状态有啥区别？"><a href="#_301和302-http状态有啥区别？" class="header-anchor">#</a> 301和302 Http状态有啥区别？</h3> <p>301，302 都是HTTP状态的编码，都代表着某个URL发生了转移，不同之处在于：</p> <ul><li><p>301 redirect: 301 代表永久性转移(Permanently Moved)，</p></li> <li><p>302 redirect: 302 代表暂时性转移(Temporarily Moved )，</p></li></ul> <p>当然　Http 状态 200 标示没有任何问题发生。</p> <h3 id="get和post有什么区别？"><a href="#get和post有什么区别？" class="header-anchor">#</a> GET和POST有什么区别？</h3> <ul><li>数据传输方式不同：GET请求通过URL传输数据，而POST的数据通过请求体传输。</li> <li>安全性不同：POST的数据因为在请求主体内，所以有一定的安全性保证，而GET的数据在URL中，通过历史记录，缓存很容易查到数据信息。</li> <li>数据类型不同：GET只允许 ASCII 字符，而POST无限制</li> <li>GET无害： 刷新、后退等浏览器操作GET请求是无害的，POST可能重复提交表单</li> <li>特性不同：GET是安全（这里的安全是指只读特性，就是使用这个方法不会引起服务器状态变化）且幂等（幂等的概念是指同一个请求方法执行多次和仅执行一次的效果完全相同），而- - POST是非安全非幂等</li></ul> <h3 id="put和post都是给服务器发送新增资源，有什么区别？"><a href="#put和post都是给服务器发送新增资源，有什么区别？" class="header-anchor">#</a> PUT和POST都是给服务器发送新增资源，有什么区别？</h3> <p>PUT 和POST方法的区别是,PUT方法是幂等的：连续调用一次或者多次的效果相同（无副作用），而POST方法是非幂等的。
除此之外还有一个区别，通常情况下，PUT的URI指向是具体单一资源，而POST可以指向资源集合。
举个例子，我们在开发一个博客系统，当我们要创建一篇文章的时候往往用POST https://www.jianshu.com/articles，这个请求的语义是，在articles的资源集合下创建一篇新的文章，如果我们多次提交这个请求会创建多个文章，这是非幂等的。
而PUT https://www.jianshu.com/articles/820357430的语义是更新对应文章下的资源（比如修改作者名称等），这个URI指向的就是单一资源，而且是幂等的，比如你把『刘德华』修改成『蔡徐坤』，提交多少次都是修改成『蔡徐坤』</p> <h3 id="什么是跨域"><a href="#什么是跨域" class="header-anchor">#</a> 什么是跨域?</h3> <p>跨域，指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对JavaScript施加的安全限制。</p> <h3 id="什么是同源策略？"><a href="#什么是同源策略？" class="header-anchor">#</a> 什么是同源策略？</h3> <p>同源策略/SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到 XSS 、 CSFR 等攻击。所谓同源是指&quot;协议+域名+端口&quot;三者相同，即便两个不同的域名指向同一个ip地址，也非同源。</p> <ul><li>同源策略限制了以下行为：
<ul><li>Cookie、LocalStorage 和 IndexDB 无法读取</li> <li>DOM 和 JS对象无法获取</li> <li>Ajax请求发送不出去</li></ul></li> <li>解决跨域
<ul><li>jsonp 跨域</li> <li>document.domain + iframe 跨域</li> <li>window.name + iframe 跨域</li> <li>location.hash + iframe 跨域</li> <li>postMessage 跨域</li> <li>跨域资源共享CORS</li> <li>withCredentials 属性</li> <li>WebSocket 协议跨域</li> <li>node 代理跨域</li> <li>nginx 代理跨域</li></ul></li></ul> <h3 id="什么是options预请求？"><a href="#什么是options预请求？" class="header-anchor">#</a> 什么是options预请求？</h3> <p><code>options</code>预请求是浏览器自主发起的，分别根据预检请求报文中的 <code>Access-Control-Request-Method</code>、<code>Access-Control-Request-Headers</code>来判断该请求是否是服务器允许的提交方式和允许的请求头字段；
服务器基于从预检请求获得的信息来判断，是否接受接下来的实际请求。</p> <h3 id="解释一下事件冒泡和事件捕获呢？如何阻止冒泡？如何阻止默认事件？手写一个事件委托的例子呢？"><a href="#解释一下事件冒泡和事件捕获呢？如何阻止冒泡？如何阻止默认事件？手写一个事件委托的例子呢？" class="header-anchor">#</a> 解释一下事件冒泡和事件捕获呢？如何阻止冒泡？如何阻止默认事件？手写一个事件委托的例子呢？</h3> <p>一个完整的JS事件流是从window开始，最后回到window的一个过程；
事件流被分为三个阶段(1 ~ 5)捕获过程、(5 ~ 6)目标过程、(6 ~ 10)冒泡过程。
事件冒泡就是事件从最深的节点开始，然后逐步向上传播事件的过程；
事件捕获就是从window开始，逐步向最深的节点传播事件的过程.</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 事件委托：就是把事件处理器添加到父元素，等待子元素事件冒泡，并且父元素能够通过target（IE为srcElement）判断是哪个子元素，从而做相应处理</span>

<span class="token keyword">var</span> ul <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementByTagName</span><span class="token punctuation">(</span>'ul<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
ul<span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  e <span class="token operator">=</span> e <span class="token operator">||</span> window<span class="token punctuation">.</span>event
  <span class="token function">alert</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>innerHtml<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 阻止冒泡: window.event? window.event.cancelBubble = true(IE) : e.stopPropagation()</span>
<span class="token comment">// 阻止默认事件: e.preventDefault() || window.event.returnValue = false(IE)</span>
</code></pre></div><h3 id="请描述一下内存泄漏的原因和场景？那js的垃圾回收机制有哪些？"><a href="#请描述一下内存泄漏的原因和场景？那js的垃圾回收机制有哪些？" class="header-anchor">#</a> 请描述一下内存泄漏的原因和场景？那js的垃圾回收机制有哪些？</h3> <p>内存泄漏指的是浏览器不能正常的回收内存的现象</p> <p>1.全局变量引起的内存泄漏
2.闭包引起的内存泄漏
3.dom清空或删除时，事件未清除导致的内存泄漏
当函数执行结束，局部变量就不需要了，这时候就可以释放他们的内存。</p> <p>两种回收机制：</p> <ul><li>引用计数法
跟踪记录每个值被引用的次数。当声明一个变量并将引用类型的值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次 数加1.相反，如果包含对这个值引用的变量又取得另外一个值，则这个值的引用次数减1.当这个值的引用次数变成0时，则说明没有办法访问这个值了，因此就 可以将其占用的内存空间回收回来</li> <li>标记清除法
标记清除的算法分为两个阶段，标记(mark)和清除(sweep) 第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除。</li></ul> <h3 id="dom事件中target和currenttarget的区别"><a href="#dom事件中target和currenttarget的区别" class="header-anchor">#</a> DOM事件中target和currentTarget的区别</h3> <ul><li>event.target 返回触发事件的元素</li> <li>event.currentTarget 返回绑定事件的元素</li></ul> <h3 id="跨域的几种方式？"><a href="#跨域的几种方式？" class="header-anchor">#</a> 跨域的几种方式？</h3> <ul><li>利用script标签的跨域能力）跨域</li> <li>websocket（html5的新特性，是一种新协议）跨域</li> <li>设置代理服务器（由服务器替我们向不同源的服务器请求数据）</li> <li>CORS（跨源资源共享，cross origin resource sharing）</li> <li>iframe跨域</li> <li>postMessage(包含iframe的页面向iframe传递消息)</li></ul></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/liweirose/knowledge/edit/master/docs/app/Interview/Interview-network.md" target="_blank" rel="noopener noreferrer">在 GitHub 上编辑此页</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">6/25/2019, 1:51:41 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/knowledge/app/Interview/Interview-javascript.html" class="prev">JavaScript</a></span> <span class="next"><a href="/knowledge/app/Interview/interview-browser.html">Browser</a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/knowledge/assets/js/app.c7c9f3cb.js" defer></script><script src="/knowledge/assets/js/2.d289c607.js" defer></script><script src="/knowledge/assets/js/35.574acac1.js" defer></script>
  </body>
</html>
