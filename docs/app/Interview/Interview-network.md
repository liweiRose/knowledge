# Network

### TCP 三次握手 四次挥手

建立和断开连接的一种策略



```js
1. 连接

  ① 发送端 发送 一个带SYN标志的数据包 给接收端

  ② 接收端收到后，回传 一个带有SYN/ACK标志的数据包 确认收到了信息

  ③ 发送端再回传 一个带ACK标志的数据包 代表“握手”结束

 tips: 若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包
2. 断开 TCP 连接

  ① 主动关闭方 发送一个 FIN (告知对方我已经不再发送数据了)

  ② 被动关闭方 收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1

  ③ 被动关闭方 再发送一个FIN （ 告诉主动关闭方，我的数据也发送完了，不会再给你发数据了 ）

  ④ 主动关闭方 收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1

```

### TCP 和 UDP 的区别
```js
1. TCP（Transmission Control Protocol，传输控制协议）

  - TCP 是基于连接的协议，在正式收发数据前，必须和对方建立可靠的连接。
  - 一个 TCP 连接必须要经过三次“对话”才能建立起来。

2. UDP（User Data Protocol，用户数据报协议）

  - UDP 是与 TCP 相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去。

  - UDP 适用于一次只传送少量数据、对可靠性要求不高的应用环境。
```


### 常见 web 安全
```js
1. Xss(cross-site scripting)攻击

- 指的是攻击者往 Web 页面里插入恶意 html 标签或者 javascript 代码

- 如：攻击者在论坛中加一个恶意表单

  - 如果网站不需要再浏览器端对 cookie 进行操作，可以在 Set-Cookie 末尾加上 HttpOnly 
    来防止 javascript 代码直接获取 cookie
  - 尽量采用 POST 而非 GET 提交表单

2. CSRF 攻击

- CSRF 是代替用户完成指定的动作

- 完成一次 CSRF 攻击，受害者必须依次完成两个步骤：

  - 登录受信任网站 A，并在本地生成 Cookie
  - 在不登出 A 的情况下，访问危险网站 B

- 在客户端页面增加伪随机数以防御
```

### HTTP 和 HTTPS
```js
1. HTTP

- HTTP 协议通常承载于 TCP 协议之上
- 默认 HTTP 的端口号为 80

2. HTTPS

- 在 HTTP 和 TCP 之间添加一个安全协议层（SSL 或 TSL）

- HTTPS 的端口号为 443

- 安全性强

  - 因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，所以 HTTP 存在安全性问题

  - 使用 HTTPS，密钥在你和终点站才有。

  - 利用 ssl/tls 协议传输 (它包含证书，卸载，流量转发，负载均衡，页面适配，浏览器适配，refer 传递等)

  - 从而保障了传输过程的安全性。

3. Http 2.0

- HTTP/2  引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前就主动地将数据
          发送到客户端缓存中，从而提高性能。

- HTTP/2  提供更多的加密支持。

- HTTP/2  使用多路技术，允许多个消息在一个连接上同时交差。

- HTTP/2  增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的 header 
          都只会占用很小比例的带宽。
```



### Cookie 和 session

- Cookie 是一种存储机制，提供持久保存客户端数据的能力

- session 对象存储在 Cookie 中， 保存一些常用的信息，如：access_token/user_info

- cookie 数据存放在客户的浏览器上，session 数据放在服务器上

- 每个特定的域名下最多生成 20 个 Cookie

- Cookie 的最大约为 4096 字节，为了兼容性，一般不能超过 4095 字节

- 每次请求一个新的页面 Cookie 都会被发送过去

#### 应用

由于 http 无状态，所以需要存在一种机制去标识状态

```
- 基于 Cookie 的身份验证 & 验证流程

  - 因为 cookie 验证有状态 所以会话信息(session) 同时保存在客户端(cookie) 和 服务端(sql)

  - cookie 绑定单域 a.com 生成的不能再 b.com 中用

  - 流程:
    - 用户登录获取凭证
    - 服务器验证凭证正确与否
    - 若验证通过创建会话（set-cookie）(服务端存一份，浏览器端直接写入到 cookie，根据是否设置 http-only 决定浏览器端是否可操作 cookie，获取 session 拿到凭证信息)
    - 后续请求均走上述验证流程
    - 若 用户登出 则服务端与浏览器端同时清除 session

- 基于 Token 的身份验证 & 验证流程

  - 基于 JWT（JSON Web Tokens）生成 token
  - 服务端不需要记录 token
  - 多站点使用
  - 支持 ios/Android
  - 性能较好

  - 流程：
    - 用户登录获取凭证
    - 服务器验证凭证，成功则返回一个已经签名后的 token
    - 客服端存储 token
    - 客服端请求，头里带上 token
    - 服务端校验 token 合法性, 是否过期等
    - 用户登出 客户端销毁 token
```

### sessionStorage 和 localStorage
```js
1. sessionStorage

sessionStorage 用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且
当会话结束后数据也随之销毁。因此 sessionStorage 不是一种持久化的本地存储，仅仅是会话级别的存储。

2. localStorage

localStorage 用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。
```



### 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？

- （1) 当发送一个 URL 请求时，不管这个 URL 是 Web 页面的 URL 还是 Web 页面上每个资源的 URL，浏览器都会开启一个线程来处理这个请求，同时在远程 DNS 服务器上启动一个  DNS 查询。这能使浏览器获得请求对应的 IP 地址。

- （2)浏览器与远程`Web`服务器通过`TCP`三次握手协商来建立一个`TCP/IP`连接。该握手包括一个同步报文，一个同步-应答报文和一个应答报文， 这三个报文在 浏览器和服务器之间传递。该握手首先由客户端尝试建立起通信，而后服务器应答并接受客户端的请求，最后由客户端发出该请求已经被接受的报文。

- （3)一旦`TCP/IP`连接建立，浏览器会通过该连接向远程服务器发送`HTTP`的`GET`请求。远程服务器找到资源并使用 HTTP 响应返回该资源，值为 200 的 HTTP 响应状态表示一个正确的响应。

- （4)此时，`Web`服务器提供资源服务，客户端开始下载资源。

- （5)前端层面，浏览器会解析`HTML`生成`DOM Tree`，其次会根据 CSS 生成 CSS Rule Tree，而`javascript`又可以根据`DOM API`操作`DOM`

```

  详细版：
  1、浏览器会开启一个线程来处理这个请求，对 URL 分析判断如果是 http 协议就按照 Web 方式来处理;
  2、调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法;
  3、通过 DNS 解析获取网址的 IP 地址，设置 UA 等信息发出第二个 GET 请求;
  4、进行 HTTP 协议会话，客户端发送报头(请求报头);
  5、进入到 web 服务器上的 Web Server，如 Apache、Tomcat、Node.JS 等服务器;
  6、进入部署好的后端应用，如 PHP、Java、JavaScript、Python 等，找到对应的请求处理;
  7、处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致则返回 304;
  8、浏览器开始下载 html 文档(响应报头，状态码 200)，同时使用缓存;
  9、文档树建立，根据标记请求所需指定 MIME 类型的文件（比如 css、js）,同时设置了 cookie;
  10、页面开始渲染 DOM，JS 根据 DOM API 操作 DOM,执行事件绑定等，页面显示完成。

  简洁版：
  浏览器根据请求的 URL 交给 DNS 域名解析，找到真实 IP，向服务器发起请求；
  服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）；
  浏览器对加载到的资源（HTML、JS、CSS 等）进行语法解析，建立相应的内部数据结构（如 HTML 的 DOM）；
  载入解析到的资源文件，渲染页面，完成。

```

> 这里可扩展，这里只是简单说说

### 同源策略

- 指的是：协议，域名，端口相同，同源策略是一种安全协议

- 为什么要有同源限制?
  - 因为可以利用 Iframe 把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过 Javascript 读取到你的表单中 input 中的内容

### GET 和 POST 的区别，何时使用 POST？

- GET：一般用于信息获取，使用 URL 传递参数，对所发送信息的数量也有限制，一般在 2000 个字符

- POST：一般用于修改服务器上的资源，对所发送的信息没有限制。

- GET 方式需要使用 Request.QueryString 来取得变量的值，而 POST 方式通过 Request.Form 来获取变量的值，也就是说 Get 是通过地址栏来传值，而 Post 是通过提交表单来传值。

- 然而，在以下情况中，请使用 POST 请求：

  - 无法使用缓存文件（更新服务器上的文件或数据库）

  - 向服务器发送大量数据（POST 没有数据量限制）

  - 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠

### HTTP 状态码

```js

- 100 Continue 继续，一般在发送 post 请求时，
      已发送了 http header 之后服务端将返回此信息，表示确认，之后发送具体参数信息

- 200 OK 正常返回信息

- 201 Created 请求成功并且服务器创建了新的资源

- 202 Accepted 服务器已接受请求，但尚未处理

- 301 Moved Permanently 请求的网页已永久移动到新位置。

- 302 Found 临时性重定向。

- 303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。

- 304 Not Modified 自从上次请求后，请求的网页未修改过。

- 400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。

- 401 Unauthorized 请求未授权。

- 403 Forbidden 禁止访问。

- 404 Not Found 找不到如何与 URI 相匹配的资源。

- 500 Internal Server Error 最常见的服务器端错误。

- 503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。

```

### 网络七层模型

- 应用层：应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS）

- 传输层（TCP 和 UDP）

- 网络层（IP）

- 物理和数据链路层（以太网）

```js

  物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）

  数据链路层：将比特组装成帧和点到点的传递（帧Frame）

  网络层：负责数据包从源到宿的传递和网际互连（包PackeT）

  传输层：提供端到端的可靠报文传递和错误恢复（段Segment）

  会话层：建立、管理和终止会话（会话协议数据单元SPDU）

  表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）

  应用层：允许访问OSI环境的手段（应用协议数据单元APDU）

```

### 网络协议

```js

ICMP 协议： 因特网控制报文协议。它是 TCP/IP 协议族的一个子协议，用于在 IP 主机、路由器之间传递控制消息。

TFTP 协议： 是 TCP/IP 协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。

HTTP 协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。

DHCP 协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段。

```
### 创建ajax过程

```
(1)创建XMLHttpRequest对象,也就是创建一个异步调用对象.

(2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息.

(3)设置响应HTTP请求状态变化的函数.

(4)发送HTTP请求.

(5)获取异步调用返回的数据.

(6)使用JavaScript和DOM实现局部刷新.
```
```js
var xmlHttp = new XMLHttpRequest();

    xmlHttp.open('GET','demo.php','true');

    xmlHttp.send()

    xmlHttp.onreadystatechange = function(){

        if(xmlHttp.readyState === 4 & xmlHttp.status === 200){

        }

    }
```
### 谈谈性能优化问题

代码层面：避免使用css表达式，避免使用高级选择器，通配选择器。

缓存利用：缓存Ajax，使用CDN，使用外部js和css文件以便缓存，添加Expires头，服务端配置Etag，减少DNS查找等

请求数量：合并样式和脚本，使用css图片精灵，初始首屏之外的图片资源按需加载，静态资源延迟加载。

请求带宽：压缩文件，开启GZIP，

代码优化:

- 用`hash-table`来优化查找
- 少用全局变量
- 用`innerHTML`代替`DOM`操作，减少`DOM`操作次数，优化`javascript`性能
- 用`setTimeout`来避免页面失去响应
- 缓存DOM节点查找的结果
- 避免使用CSS Expression
- 避免全局查询
- 避免使用with(with会创建自己的作用域，会增加作用域链长度)
- 多个变量声明合并
- 避免图片和iFrame等的空Src。空Src会重新加载当前页面，影响速度和效率
- 尽量避免写在HTML标签中写Style属性
### 渲染优化
```js
    1.禁止使用iframe（阻塞父文档onload事件）；
        *iframe会阻塞主页面的Onload事件；
        *搜索引擎的检索程序无法解读这种页面，不利于SEO;
        *iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。

        使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript
        动态给iframe添加src属性值，这样可以绕开以上两个问题。

    2.禁止使用gif图片实现loading效果（降低CPU消耗，提升渲染性能）；
    3、使用CSS3代码代替JS动画（尽可能避免重绘重排以及回流）；
    4、对于一些小图标，可以使用base64位编码，以减少网络请求。但不建议大图使用，比较耗费CPU；
            小图标优势在于：
                1.减少HTTP请求；
                2.避免文件跨域；
                3.修改及时生效；

    5、页面头部的<style></style> 会阻塞页面；（因为 Renderer进程中 JS线程和渲染线程是互斥的）；
    6、页面头部<script</script> 会阻塞页面；（因为 Renderer进程中 JS线程和渲染线程是互斥的）；
    7、页面中空的 href 和 src 会阻塞页面其他资源的加载 (阻塞下载进程)；
    
    8、网页Gzip，CDN托管，data缓存 ，图片服务器；
    9、前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数
    10、用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。
    11、当需要设置的样式很多时设置className而不是直接操作style。
    12、少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。
    13、避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。
    14、图片预加载，将样式表放在顶部，将脚本放在底部  加上时间戳。

    15、 避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢。
        对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘IO。
            向前端优化指的是，在不影响功能和体验的情况下，能在浏览器执行的不要在服务端执行，
            能在缓存服务器上直接返回的不要到应用服务器，程序能直接取得的结果不要到外部取得，
            本机内能取得的数据不要到远程取，内存能取到的不要到磁盘取，缓存中有的不要去数据库查询。
            减少数据库操作指减少更新次数、缓存结果减少查询次数、将数据库执行的操作尽可能的让你的程序完成（例如join查询），
            减少磁盘IO指尽量不使用文件系统作为缓存、减少读写文件次数等。程序优化永远要优化慢的部分，换语言是无法“优化”的。
            
```
### 什么是Etag

当发送一个服务器请求时，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断缓存文件是否过期。

情景一：若没有过期，则不向服务器发送请求，直接使用缓存中的结果，此时我们在浏览器控制台中可以看到 `200 OK`(from cache) ，此时的情况就是完全使用缓存，浏览器和服务器没有任何交互的。

情景二：若已过期，则向服务器发送请求，此时请求中会带上①中设置的文件修改时间，和`Etag`

然后，进行资源更新判断。服务器根据浏览器传过来的文件修改时间，判断自浏览器上一次请求之后，文件是不是没有被修改过；根据`Etag`，判断文件内容自上一次请求之后，有没有发生变化

情形一：若两种判断的结论都是文件没有被修改过，则服务器就不给浏览器发`index.html`的内容了，直接告诉它，文件没有被修改过，你用你那边的缓存吧—— `304 Not Modified`，此时浏览器就会从本地缓存中获取`index.html`的内容。此时的情况叫协议缓存，浏览器和服务器之间有一次请求交互。

情形二：若修改时间和文件内容判断有任意一个没有通过，则服务器会受理此次请求，之后的操作同①

只有get请求会被缓存，post请求不会.
### Expires和Cache-Control

`Expires`要求客户端和服务端的时钟严格同步。`HTTP1.1`引入`Cache-Control`来克服Expires头的限制。如果max-age和Expires同时出现，则max-age有更高的优先级。

```
    Cache-Control: no-cache, private, max-age=0

    ETag: abcde

    Expires: Thu, 15 Apr 201420180515 20:00:00 GMT

    Pragma: private

    Last-Modified: $now // RFC1123 format
```
### ETag应用:

`Etag`由服务器端生成，客户端通过`If-Match`或者说`If-None-Match`这个条件判断请求来验证资源是否修改。常见的是使用`If-None-Match`。请求一个文件的流程可能如下：

====第一次请求===

```
1.客户端发起 HTTP GET 请求一个文件；

2.服务器处理请求，返回文件内容和一堆Header，当然包括Etag(例如"2e681a-6-5d044840")(假设服务器支持Etag生成和已经开启了Etag).状态码200
```

====第二次请求===

```
客户端发起 HTTP GET 请求一个文件，注意这个时候客户端同时发送一个If-None-Match头，这个头的内容就是第一次请求时服务器返回的Etag：2e681a-6-5d0448402.服务器判断发送过来的Etag和计算出来的Etag匹配，因此If-None-Match为False，不返回200，返回304，客户端继续使用本地缓存；流程很简单，问题是，如果服务器又设置了Cache-Control:max-age和Expires呢，怎么办
```

答案是同时使用，也就是说在完全匹配`If-Modified-Since`和`If-None-Match`即检查完修改时间和`Etag`之后，

服务器才能返回304.(不要陷入到底使用谁的问题怪圈)

为什么使用Etag请求头?

Etag 主要为了解决 `Last-Modified` 无法解决的一些问题。
### 关于Http 2.0 你知道多少

`HTTP/2`引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前就主动地将数据发送到客户端缓存中，从而提高性能。

`HTTP/2`提供更多的加密支持

`HTTP/2`使用多路技术，允许多个消息在一个连接上同时交差。

它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的`header`都只会占用很小比例的带宽。
### WebSocket
由于 http 存在一个明显的弊端（消息只能有客户端推送到服务器端，而服务器端不能主动推送到客户端），导致如果服务器如果有连续的变化，这时只能使用轮询，而轮询效率过低，并不适合。于是 WebSocket 被发明出来。

相比与 http 具有以下有点：
- 支持双向通信，实时性更强；
- 可以发送文本，也可以二进制文件；
- 协议标识符是 ws，加密后是 wss ；
- 较少的控制开销。连接创建后，ws客户端、服务端进行数据交换时，协议控制的数据包头部较小。在不包含头部的情况下，服务端到客户端的包头只有2~10字节（取决于数据包长度），客- 户端到服务端的的话，需要加上额外的4字节的掩码。而HTTP协议每次通信都需要携带完整的头部；
- 支持扩展。ws协议定义了扩展，用户可以扩展协议，或者实现自定义的子协议。（比如支持自定义压缩算法等）
- 无跨域问题。
实现比较简单，服务端库如 socket.io、ws ，可以很好的帮助我们入门。而客户端也只需要参照 api 实现即可。
### 浏览器缓存
浏览器缓存分为强缓存和协商缓存。当客户端请求某个资源时，获取缓存的流程如下：

- 先根据这个资源的一些 http header 判断它是否命中强缓存，如果命中，则直接从本地获取缓存资源，不会发请求到服务器；
- 当强缓存没有命中时，客户端会发送请求到服务器，服务器通过另一些request header验证这个资源是否命中协商缓存，称为http再验证，如果命中，服务器将请求返回，但不返回资源，而是告诉客户端直接从缓存中获取，客户端收到返回后就会从缓存中获取资源；
- 强缓存和协商缓存共同之处在于，如果命中缓存，服务器都不会返回资源；
- 区别是，强缓存不对发送请求到服务器，但协商缓存会。
- 当协商缓存也没命中时，服务器就会将资源发送回客户端。
- 当 ctrl+f5 强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；
- 当 f5 刷新网页时，跳过强缓存，但是会检查协商缓存；
#### 强缓存

- Expires（该字段是 http1.0 时的规范，值为一个绝对时间的 GMT 格式的时间字符串，代表缓存资源的过期时间）
- Cache-Control:max-age（该字段是 http1.1 的规范，强缓存利用其 max-age 值来判断缓存资源的最大生命周期，它的值单位为秒）
#### 协商缓存

- Last-Modified（值为资源最后更新时间，随服务器response返回）
- If-Modified-Since（通过比较两个时间来判断资源在两次请求期间是否有过修改，如果没有修改，则命中协商缓存）
- ETag（表示资源内容的唯一标识，随服务器response返回）
- If-None-Match（服务器通过比较请求头部的If-None-Match与当前资源的ETag是否一致来判断资源是否在两次请求之间有过修改，如果没有修改，则命中协商缓存）
### HTTP 和 HTTPS 有何差异?

`HTTP`相对于 `HTTPS`来说,速度较快且开销较小(没有 SSL/TSL) 对接,默认是80端口;

HTTP容易遭受域名劫持,而HTTPS相对来说就较为安全但开销较大(数据以加密的形式传递),默认端口为443..
`
HTTP是明文跑在 TCP 上.而HTTPS跑在SSL/TLS应用层之下,TCP上的
### 你对 HTTP 的状态吗了解多少...
- 1XX: 一般用来判断协议更换或者确认服务端收到请求这些

  - 100: 服务端收到部分请求,若是没有拒绝的情况下可以继续传递后续内容
  - 101: 客户端请求变换协议,服务端收到确认


- 2xx: 请求成功,是否创建链接,请求是否接受,是否有内容这些

  - 200: (成功)服务器已成功处理了请求。
  - 201: (已创建)请求成功并且服务器创建了新的资源。
  - 202: (已接受)服务器已接受请求，但尚未处理。
  - 204: (无内容)服务器成功处理了请求，但没有返回任何内容。


- 3XX: 一般用来判断重定向和缓存

  - 301: 所有请求已经转移到新的 url(永久重定向),会被缓存
  - 302: 临时重定向,不会被缓存
  - 304: 本地资源暂未改动,优先使用本地的(根据If-Modified-Since or If-Match去比对服务器的资源,缓存)

- 4XX: 一般用来确认授权信息,请求是否出错,页面是否丢失

  - 400: 请求出错
  - 401: 未授权,不能读取某些资源
  - 403: 阻止访问,一般也是权限问题
  - 404: 页面丢失,资源没找到
  - 408: 请求超时
  - 415: 媒介类型不被支持，服务器不会接受请求。


- 5XX: 基本都是服务端的错误

  - 500: 服务端错误
  - 502: 网关错误
  - 504: 网关超时
### 从你输入一个 URL 到页面渲染的大体过程...
- IP->DNS(浏览器=>系统缓存=>DNS 服务器)->域名解析完成(这一步不用太多解析吧)
- TCP 协议走完->HTTP(S) 协议->缓存->(分析请求头)-> 回馈报文
- 请求文档下来->DOM->CSSDOM->静态资源下载->render(绘制文档)->js 解析
- 用户看到页面
### HTTP的几种请求方法用途
1、GET方法

发送一个请求来取得服务器上的某一资源



2、POST方法

向URL指定的资源提交数据或附加新的数据



3、PUT方法

跟POST方法很像，也是想服务器提交数据。但是，它们之间有不同。PUT指定了资源在服务器上的位置，而POST没有



4、HEAD方法

只请求页面的首部



5、DELETE方法

删除服务器上的某资源



6、OPTIONS方法

它用于获取当前URL所支持的方法。如果请求成功，会有一个Allow的头包含类似“GET,POST”这样的信息



7、TRACE方法


TRACE方法被用于激发一个远程的，应用层的请求消息回路



8、CONNECT方法

把请求连接转换到透明的TCP/IP通道